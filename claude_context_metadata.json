{
  "app.vue": {
    "hash": "b42ba9ed4ba11b0028fb9fbfeb3215eb",
    "last_updated": 1753904225.691476,
    "summary": "This is a Vue.js single-file component that serves as the main application root component. The template section defines the core layout structure using Nuxt-specific components: NuxtRouteAnnouncer for accessibility announcements, NuxtLayout for layout management, and NuxtPage for page rendering. The script section uses the Composition API with setup syntax but is currently empty except for a comment indicating that global state initialization has been moved to a plugin. This follows the Nuxt 3+ pattern of using built-in components for routing and layout handling, with no custom methods, functions, or complex logic present in this root component file."
  },
  "nuxt.config.ts": {
    "hash": "b3b8f18b5d472597db2504bf1cf3d7a0",
    "last_updated": 1753904228.5124097,
    "summary": "This is a Nuxt 3 configuration file (nuxt.config.ts) that sets up a comprehensive web application for tracking cycling and motorbike adventures. The configuration enables Server-Side Rendering (ssr: true) and HTTPS development server on port 3000.\n\nKey modules integrated include:\n- @nuxt/eslint (code linting)\n- @nuxt/icon (icon management)\n- @nuxt/image (image optimization)\n- @nuxtjs/tailwindcss (styling framework)\n- @vueuse/nuxt (Vue composition utilities)\n\nThe app configuration defines SEO metadata with a descriptive title and viewport settings optimized for mobile devices, along with favicon linking. Page and layout transitions are configured with 'out-in' mode for smooth navigation.\n\nEnvironment variables are managed through runtimeConfig, supporting both MemFire Cloud (Supabase-compatible) and legacy Supabase configurations, plus AMap (Chinese mapping service) API keys. The Vue compiler is configured to recognize custom elements starting with 'amap-'.\n\nPerformance optimizations include:\n- Vite configuration to suppress hydration warnings\n- Nitro compression for public assets\n- Image optimization with webp/avif formats and responsive breakpoints\n- Tailwind CSS with a custom primary color palette\n\nThe application is designed as a mobile-first GPS tracking solution with PWA-like capabilities and responsive design patterns."
  },
  "package.json": {
    "hash": "c92ecf00ae8bc726ac0ef61ed795c901",
    "last_updated": 1753904235.0002403,
    "summary": "This is a package.json file for a Nuxt 3 application. The project is named 'nuxt-app' and is configured as a private module with ES module type. \n\nKey scripts include:\n- Development commands: 'dev' for standard development server, 'dev:clean' for development with deprecation warnings disabled\n- Build commands: 'build' for production builds, 'build:prod' with deprecation warnings disabled, 'generate' for static site generation\n- Utility commands: 'preview' for previewing built applications, 'postinstall' for Nuxt preparation after installation\n- Platform-specific setup scripts: 'setup:windows' (Node.js script), 'setup:macos' and 'setup:linux' (bash scripts)\n\nThe application uses a modern Vue 3 stack with Nuxt 3.17.6, including:\n- UI components: @headlessui/vue and @heroicons/vue for accessible UI components and icons\n- Styling: @nuxtjs/tailwindcss for Tailwind CSS integration\n- Backend integration: @supabase/supabase-js for Supabase backend services\n- Utilities: @vueuse/core and @vueuse/nuxt for Vue composition utilities\n- Image handling: @nuxt/image for optimized image processing\n- Code quality: @nuxt/eslint and eslint for linting\n\nDev dependencies include cross-env for cross-platform environment variable support. The project follows a modular pattern with platform-specific setup scripts and utilizes modern JavaScript/TypeScript development practices with comprehensive build and development tooling."
  },
  "test-polyline.js": {
    "hash": "9b8aa0fffea82562e78bf3875b5080e8",
    "last_updated": 1753904240.844761,
    "summary": "This file is a comprehensive test suite for polyline functionality, designed to verify coordinate normalization, path processing, distance calculations, and configuration handling. The code is structured around four main test functions:\n\n1. **testCoordinateNormalization()** - Tests coordinate format conversion with three test cases: array coordinates, object with lng/lat properties, and AMap LngLat-like objects with getter methods. It includes a mock normalizeCoordinates() function that handles different coordinate formats.\n\n2. **testPathNormalization()** - Tests polyline path processing by converting coordinate arrays into mock AMap.LngLat objects using a mock constructor and normalization function.\n\n3. **testDistanceCalculation()** - Implements and tests the Haversine formula for calculating distances between coordinates, using Beijing to Shanghai as a test case with tolerance checking.\n\n4. **testPolylineConfiguration()** - Tests configuration object merging using JavaScript spread operator to combine default and custom polyline settings.\n\nThe file employs several key patterns:\n- Test-driven development with explicit pass/fail validation\n- Mock object creation for testing AMap (Alibaba Maps) API compatibility\n- Error handling with try/catch blocks\n- Environment detection for both browser (window object) and Node.js (module system) execution\n- Console-based reporting with visual indicators (✓/✗) and detailed output\n\nThe overall purpose is to ensure polyline coordinate handling works correctly across different input formats and to validate core GIS functionality like distance calculations. The tests are designed to be runnable in both browser console and Node.js environments, making it a versatile testing tool for polyline-related code."
  },
  "tsconfig.json": {
    "hash": "0fac5c1cfa8521b2091133f39e89c39d",
    "last_updated": 1753904246.3683708,
    "summary": "This is a TypeScript configuration file (tsconfig.json) that extends the Nuxt.js framework's generated TypeScript configuration. The file contains a single 'extends' property that references './.nuxt/tsconfig.json', which is automatically generated by Nuxt.js. This pattern allows the project to inherit all the TypeScript compiler options and settings defined by Nuxt.js while potentially allowing for custom overrides. The file serves as a configuration bridge between the project's TypeScript setup and the framework's recommended TypeScript settings. There are no methods or functions defined in this file, as tsconfig.json is purely a configuration file used by the TypeScript compiler to determine how to compile and type-check the project's TypeScript code."
  },
  "assets\\css\\main.css": {
    "hash": "31c2cba9f6098a49be4f9841df61f490",
    "last_updated": 1753904249.208,
    "summary": "This CSS file is a comprehensive styling solution built with Tailwind CSS, structured using Tailwind's @layer directive to organize base styles, component classes, and utility classes. The file implements a mobile-first responsive design approach with specific optimizations for touch interfaces and mobile devices.\n\nKey Features and Patterns:\n\n1. Base Styles (@layer base):\n   - Mobile-first typography with responsive font sizing (14px base, 16px on small screens)\n   - Touch optimization with -webkit-tap-highlight-color removal\n   - Mobile input optimization (prevents zoom on focus with 16px font size)\n   - Cross-browser button style normalization\n   - Body styling with background, text color, and smooth font rendering\n\n2. Component Classes (@layer components):\n   - Button system with .btn base class and variants (.btn-primary, .btn-secondary, .btn-ghost)\n   - Touch-optimized sizing (44px minimum touch targets per iOS guidelines)\n   - Card components (.card, .card-compact) for content containers\n   - Form elements (.form-input, .form-label) with accessible focus states\n   - Mobile navigation (.mobile-nav) with safe area inset support\n   - Safe area padding utilities for mobile devices (.safe-area-*)\n   - Map container styling (.map-container)\n   - Loading spinner animation (.loading-spinner)\n   - Floating action button (.fab) with fixed positioning\n   - Status indicators (.status-indicator) with color-coded states\n\n3. Utility Classes (@layer utilities):\n   - Touch manipulation utilities (.touch-manipulation)\n   - Scroll control (.no-scroll)\n   - Text truncation helpers (.truncate-2, .truncate-3)\n\n4. Responsive Design:\n   - Media queries for mobile/desktop visibility toggling (.mobile-only, .desktop-only)\n   - Tailwind's @screen directive for breakpoint-based styles\n\n5. Animation and Transitions:\n   - Page/layout transition effects for Vue/Nuxt applications\n   - Custom pulse animation for location button (.location-button-pulse)\n\n6. Specialized Components:\n   - Global map container with z-index management\n   - Content overlay system for layered interfaces\n\nThe file demonstrates modern CSS architecture patterns including CSS-in-JS utility usage, mobile-first responsive design, touch interface optimization, and proper separation of concerns through Tailwind's layer system. It's specifically optimized for mobile applications with attention to accessibility, touch targets, and device-specific UI considerations."
  },
  "components\\ui\\AppButton.vue": {
    "hash": "e3e1abb76968c3371a03540117a0f4e4",
    "last_updated": 1753904257.4618316,
    "summary": "This is a Vue 3 component that implements a customizable button with various styling options and functionality. The component uses the Composition API with `<script setup>` syntax.\n\n## Props\n- `variant`: Button style type (primary, secondary, ghost, danger) - default: 'primary'\n- `size`: Button size (sm, md, lg, xl) - default: 'md'\n- `type`: HTML button type - default: 'button'\n- `disabled`: Disables the button - default: false\n- `loading`: Shows loading state with spinner - default: false\n- `icon`: Icon name to display - default: ''\n- `fullWidth`: Makes button full width - default: false\n\n## Methods & Functions\n- `buttonClasses` (computed): Dynamically generates CSS classes based on props, combining base styles with variant-specific, size-specific, disabled, and width classes\n- `handleClick`: Event handler that emits 'click' event only when button is not disabled or loading\n\n## Template Features\n- Conditional rendering of loading spinner (heroicons:arrow-path) when `loading` is true\n- Conditional icon display with proper spacing when icon is provided\n- Slot support for custom button content\n- Automatic margin adjustment for icons based on content presence\n- Disabled state management that prevents both clicks and visual interaction\n\n## Design Patterns\n- Uses CSS utility classes for styling (likely Tailwind CSS)\n- Implements prop validation with custom validators\n- Follows single responsibility principle with computed property handling class logic\n- Uses emit-based event handling pattern\n- Leverages Vue's reactivity system for dynamic class binding\n\n## Purpose\nThis component provides a flexible, reusable button that can be styled in multiple ways while maintaining consistent behavior across loading, disabled, and interactive states. It's designed to be a foundational UI component that can be used throughout an application."
  },
  "components\\ui\\LoadingSpinner.vue": {
    "hash": "2f1c804d073fadd6a1d22f19d73ab459",
    "last_updated": 1753904263.3919206,
    "summary": "This is a Vue 3 component that implements a customizable loading spinner with optional text. The component uses the Composition API with script setup syntax. It accepts five props: 'size' (defaulting to '32px') controls the spinner dimensions, 'text' (defaulting to empty string) displays optional accompanying text, 'containerClass' (defaulting to 'p-4') adds CSS classes to the outer container, 'spinnerClass' (defaulting to empty string) adds classes to the spinner element, and 'textClass' (defaulting to empty string) adds classes to the text element. The template uses flexbox for centering and includes conditional rendering of the text element. The component follows a functional pattern with no internal state or methods, serving purely as a presentational component. It utilizes Tailwind CSS classes for styling and includes dynamic class binding and inline styles for customization. The overall purpose is to provide a reusable, flexible loading indicator that can be easily integrated and styled throughout a Vue application."
  },
  "composables\\useAmap.ts": {
    "hash": "74cccc5714fbf06c76469d2b998dad1c",
    "last_updated": 1753904266.1596951,
    "summary": "This file contains four Vue 3 composables for integrating Amap (高德地图) functionality with GPS location tracking and route visualization. The main components are:\n\n1. **useAmap**: Handles loading the Amap JavaScript SDK with required plugins including Geolocation, Geocoder, Polyline, Marker, and MoveAnimation. Manages loading state, errors, and ensures proper plugin initialization.\n\n2. **useLocation**: Provides GPS location tracking functionality using browser Geolocation API. Includes methods for starting/stopping location tracking, getting current position, and handling location errors. Automatically applies location corrections from constants.\n\n3. **useAmapInstance**: Manages Amap map instances and provides methods for creating maps, adding markers (including custom directional arrow markers), polylines, and route visualization. Includes functionality for clearing map elements and controlling map view/zoom.\n\n4. **useRouteTracking**: Implements real-time route tracking with recording functionality. Tracks user movement, calculates distance/speed, manages recording states (start/pause/stop), and provides visual feedback through directional markers and route polylines.\n\nKey patterns include:\n- Promise-based async loading\n- Reactive state management with Vue refs\n- Automatic cleanup with onUnmounted\n- Custom SVG marker creation\n- Geospatial calculations (distance, heading)\n- Plugin architecture for map features\n- Error handling and browser environment checks\n\nThe composables work together to provide a complete GPS tracking and map visualization solution with real-time route recording capabilities."
  },
  "composables\\useGlobalMap.ts": {
    "hash": "9b74004e025f8bd786dd95b601690eea",
    "last_updated": 1753904272.178126,
    "summary": "This file implements a Vue composable for managing a global map state with location tracking and orientation features. It provides two main composables: `useGlobalMapProvider` for setting up the global map state and `useGlobalMap` for consuming it.\n\n## Key Components\n\n### Data Structures\n- `Location` interface defining location data structure with latitude, longitude, accuracy, timestamp, heading and speed\n- `GLOBAL_MAP_KEY` symbol for Vue's dependency injection system\n- `globalMapStore` reactive object storing map instance, location data, markers and tracking states\n\n### Main Composables\n\n**useGlobalMapProvider()**\n- Sets up the global map state and provides it to child components\n- Manages map instance initialization and readiness state\n- Handles location tracking through delegation to `useLocationTracking` composable\n- Manages orientation tracking through delegation to `useOrientTracking` composable\n- Controls direction marker creation and updates with proper orientation\n- Provides methods for centering map on current location\n\n**useGlobalMap()**\n- Consumes the global map state either through Vue's inject system or direct store access\n- Provides the same functionality as the provider but for components that can't inject\n\n### Core Methods\n\n**Map Management**\n- `setMapInstance()`: Initializes map instance and sets up rotation tracking\n- `centerOnCurrentLocation()`: Centers map view on current user location\n- `createDirectionMarker()`: Creates SVG arrow marker for direction indication\n- `updateDirectionMarker()`: Updates marker position and rotation\n\n**Location Services**\n- `getUserLocation()`: Retrieves user's current location with enhanced error handling\n- `updateCurrentLocation()`: Updates global store with new location data\n- `startLocationTracking()` / `stopLocationTracking()`: Controls continuous location tracking\n- `toggleLocationTracking()`: Toggles location tracking state\n\n**Orientation Services**\n- `startOrientationTracking()` / `stopOrientationTracking()`: Controls device orientation tracking\n- `calculateArrowAngle()`: Computes proper arrow rotation considering device heading and map rotation\n- `updateArrowWithRelativeOrientation()`: Updates direction marker based on current orientation\n\n### Patterns and Features\n\n- **Dependency Injection**: Uses Vue's provide/inject pattern for global state management\n- **Reactive Store**: Centralized reactive state using Vue's reactive API\n- **Composable Delegation**: Delegates specific functionality to specialized composables (`useOrientTracking`, `useLocationTracking`)\n- **Error Handling**: Comprehensive geolocation error handling with detailed user feedback\n- **Orientation Management**: Sophisticated handling of device orientation relative to map rotation\n- **Marker Management**: Dynamic creation and updating of direction markers with smooth rotation\n- **Type Safety**: TypeScript interfaces and type definitions for better code reliability\n\nThe composable supports both GPS-based location tracking and device orientation tracking, with proper synchronization between the two for accurate direction indication on the map."
  },
  "composables\\useLocationTracking.ts": {
    "hash": "28a28cb8ac757904b944e8392b748272",
    "last_updated": 1753904282.6700416,
    "summary": "This file implements a Vue 3 composable for location tracking functionality with a global reactive store. The main purpose is to provide a reusable location tracking system that can be shared across multiple components while maintaining a single source of truth.\n\n## Key Components:\n\n**Reactive Store**: A global `locationTrackingStore` object using Vue's reactive() that maintains tracking state across all component instances, including tracking status, interval ID, errors, last update time, and configurable interval duration.\n\n**Composable Function**: `useLocationTracking()` returns a comprehensive API for location tracking with:\n\n## State Management:\n- Reactive refs (`isLocationTracking`, `locationTrackingError`, `lastLocationUpdate`, `trackingInterval`) that sync with the global store via watchers\n- Automatic state synchronization between store and component refs\n\n## Core Methods:\n- `startLocationTracking()`: Initiates continuous location tracking after verifying map readiness, handles initial location acquisition, and sets up interval-based updates\n- `stopLocationTracking()`: Stops tracking and clears intervals\n- `toggleLocationTracking()`: Switches between start/stop states\n- `setTrackingInterval()`: Updates the tracking frequency\n- `isSupported()`: Checks browser geolocation support\n- `getTrackingStats()`: Returns current tracking metrics and status\n\n## Key Features:\n- **Map Readiness Check**: Waits for AMap (Alibaba Maps) to load before starting tracking\n- **Error Handling**: Comprehensive error capture for location services\n- **Automatic Cleanup**: Uses onUnmounted to prevent memory leaks\n- **Global State Persistence**: Store persists across component lifecycles\n- **Configurable Intervals**: Adjustable tracking frequency (default 3 seconds)\n\n## Design Patterns:\n- Singleton pattern via global reactive store\n- Observer pattern through Vue's watch system\n- Promise-based asynchronous operations\n- Composable architecture following Vue 3 best practices\n\nThe composable provides both simple boolean refs for UI binding and advanced methods for full location tracking control, making it suitable for mapping applications requiring real-time location updates."
  },
  "composables\\useMapPolylines.ts": {
    "hash": "c629e6e35784b18ad56d994ac22b7297",
    "last_updated": 1753904289.8358955,
    "summary": "This file implements a Vue composable for managing polylines on an AMap (高德地图) instance, specifically designed for tracking ride routes and displaying historical ride data. The composable provides a comprehensive set of functions for creating, updating, and managing polyline overlays on the map.\n\n## Core Architecture\n- Uses Vue's Composition API with reactive state management through a global polyline store\n- Integrates with a custom `useGlobalMap` composable for map instance access\n- Implements TypeScript interfaces for type safety (`TrackPolyline`, `PolylineStyle`)\n- Features predefined styles for different ride states (recording, paused, completed, preview)\n\n## Main Functionality\n\n### Ride Tracking Management\n- `startRideTracking(rideId)`: Initiates a new polyline for active ride tracking\n- `addTrackingPoint(lat, lng)`: Adds GPS coordinates to the active tracking polyline\n- `pauseRideTracking()` / `resumeRideTracking()`: Changes polyline style to reflect ride status\n- `completeRideTracking()`: Finalizes tracking and updates visual style\n- `cancelRideTracking()`: Removes active tracking polyline\n\n### Polyline Operations\n- `createPolyline(points, style, rideId)`: Creates new AMap.Polyline instance with specified parameters\n- `updatePolyline(trackPolyline, newPoints)`: Updates existing polyline with new coordinate data\n- `addPointToPolyline(trackPolyline, point)`: Appends single point to existing polyline\n- `updatePolylineStyle(trackPolyline, newStyle)`: Modifies visual properties of polyline\n\n### Historical Data Display\n- `drawHistoricalRide(rideData, style)`: Renders completed ride data as polyline\n- `recoverRidePolyline(rideData)`: Restores polyline state after page refresh with promise-based map readiness checking\n\n### Utility Functions\n- `clearAllPolylines()`: Removes all polylines from map and memory\n- `removePolyline(polylineId)`: Deletes specific polyline\n- `toggleTracking(enabled)`: Enables/disables polyline functionality\n- `fitMapToPolylines()`: Adjusts map viewport to show all polylines\n- `getPolylineStats()`: Returns statistics about current polyline state\n\n## Key Patterns\n- Reactive store pattern using Vue's `reactive()` for centralized state management\n- Map instance readiness checking with polling mechanisms\n- Comprehensive error handling with try/catch blocks and console logging\n- Automatic cleanup on component unmount\n- Type-safe operations with TypeScript interfaces\n- Promise-based asynchronous operations for map-dependent functions\n\n## State Management\nThe composable maintains a global store with:\n- Active polyline for current ride tracking\n- Array of all polylines (active + historical)\n- Tracking enabled/disabled flag\n- Historical track display settings\n\nThis implementation is optimized for real-time GPS tracking applications with robust state recovery capabilities and efficient map resource management."
  },
  "composables\\useMapSettings.ts": {
    "hash": "0449fa2d649bb2c4c2c6ed9e94e5f794",
    "last_updated": 1753904301.7372775,
    "summary": "This Vue 3 composable file manages map settings for an AMap (AutoNavi Map) integration. It provides two main composables: `useMapSettingsProvider` and `useMapSettings` following a provider-consumer pattern.\n\n## Key Components:\n\n### Constants & Types:\n- `MAP_THEMES`: Object containing 11 predefined map themes with name/value pairs\n- `MAP_FEATURES`: Object defining 4 map feature types (background, roads, buildings, points)\n- TypeScript types `MapTheme` and `MapFeature` for type safety\n\n### State Management:\n- Uses Vue's `reactive` for a global store (`mapSettingsStore`) tracking current theme and enabled features\n- Default state: 'dark' theme with all features enabled\n\n### Provider Composable (`useMapSettingsProvider`):\n- Creates and provides map settings to child components via Vue's `provide/inject` system\n- Includes map readiness checking with `waitForMapReady()` function\n- Methods: `setMapTheme()`, `setMapFeatures()`, `toggleFeature()`, `getAvailableThemes()`, `getAvailableFeatures()`\n- All map-modifying methods are async and wait for map initialization\n\n### Consumer Composable (`useMapSettings`):\n- Consumes provided settings or falls back to direct access\n- Duplicates much of the provider's functionality for direct access scenario\n- Returns same interface regardless of injection availability\n\n### Key Patterns:\n- Provider/Consumer pattern for component communication\n- Async map readiness checking with polling\n- Reactive state management with Vue 3 Composition API\n- Dependency injection for loose coupling\n- Type-safe enum-like structures with TypeScript\n\nThe file enables dynamic map theming and feature toggling while ensuring proper map initialization timing."
  },
  "composables\\useOrientTracking.ts": {
    "hash": "ef3be8a07252e2e7ca341811752dcd45",
    "last_updated": 1753904307.658914,
    "summary": "This Vue 3 composable provides device orientation tracking functionality with persistent state management across components. The file implements a reactive orientation tracking system that handles device orientation events, permission management, and cross-platform compatibility.\n\n## Core Architecture\n- Uses a global reactive store (`orientationStore`) that persists data across component instances\n- Implements individual reactive refs that sync with the global store via Vue watchers\n- Provides automatic cleanup through Vue's lifecycle hooks\n\n## Key Methods\n- `startTracking()`: Initializes orientation tracking after verifying map readiness, device support, and permissions\n- `stopTracking()`: Removes event listeners and stops tracking\n- `toggleTracking()`: Switches between start/stop states\n- `requestPermission()`: Handles iOS 13+ permission requirements for device orientation\n- `isSupported()`: Checks browser support for DeviceOrientationEvent\n\n## Platform Handling\n- Special handling for iOS 13+ permission requirements using `DeviceOrientationEvent.requestPermission()`\n- Different heading calculations for iOS (`webkitCompassHeading`) vs Android devices\n- Map readiness detection for AMap integration\n\n## State Management\nTracks multiple reactive properties: device orientation angle, tracking status, permission state, last update timestamp, and errors. The composable automatically cleans up event listeners when components unmount and provides both individual refs and direct store access for flexibility.\n\n## Design Patterns\n- Singleton pattern for the global orientation store\n- Reactive programming with Vue 3 Composition API\n- Promise-based asynchronous operations\n- Cross-browser compatibility handling\n- Type safety with TypeScript declarations"
  },
  "composables\\usePolylineDemo.ts": {
    "hash": "7a7217584cf77af17f11d23d583709e8",
    "last_updated": 1753904313.2274046,
    "summary": "This file implements a Vue 3 composable function `usePolylineDemo` for managing interactive polyline features on an AMap (高德地图) instance. The composable provides comprehensive functionality for creating, editing, drawing, and managing polylines with reactive state management.\n\n## Key Interfaces\n- `PolylineConfig`: Defines configurable properties for polyline styling including stroke color, weight, opacity, style, line joins, caps, zIndex, outline options, and direction indicators\n- `PolylineState`: Manages reactive state including polylines array, active polyline, drawing/editing modes, current path coordinates, total length, and status\n\n## Core Methods\n\n### Initialization & Setup\n- `initPolylineDemo`: Initializes the composable with a map instance, loads required AMap plugins (PolylineEditor, MouseTool), and sets up event listeners\n- `waitForPlugins`: Utility function to wait for AMap plugins to load with timeout handling\n- `setupEventListeners`: Configures event handlers for editor and drawing tools\n\n### Polyline Creation & Management\n- `createPolyline`: Creates new polylines with specified paths and configurations, converting coordinates and adding to map\n- `createSamplePolylines`: Generates sample polylines for demonstration/testing purposes\n\n### Drawing Functionality\n- `startDrawing`: Initiates interactive drawing mode using mouse tool\n- `startManualDrawing`: Begins manual point-by-point drawing mode\n- `finishManualDrawing`: Completes manual drawing and creates polyline\n- `cancelDrawing`: Cancels current drawing operation\n\n### Editing Operations\n- `editPolyline`: Activates editing mode for a polyline using PolylineEditor\n- `stopEditing`: Deactivates editing mode\n\n### Utility Operations\n- `removePolyline`: Removes a specific polyline from map and state\n- `clearAll`: Removes all polylines and resets state\n- `fitViewToPolylines`: Adjusts map view to show all polylines\n- `updatePolylineInfo`: Updates polyline length information\n- `calculatePolylineLength` and `calculateDistance`: Mathematical utilities for distance calculations using Haversine formula\n\n### Cleanup\n- `cleanup`: Comprehensive cleanup of all resources, editors, and state\n- Automatic cleanup via Vue's `onUnmounted` lifecycle hook\n\n## Patterns & Architecture\n- Uses Vue 3 Composition API with `ref`, `reactive`, and `readonly` for state management\n- Implements reactive state pattern with readonly exports for controlled mutability\n- Follows async/await pattern for plugin loading with timeout handling\n- Event-driven architecture with comprehensive event listener setup\n- Error handling with reactive error state\n- Global AMap type declarations for TypeScript support\n\nThe composable provides a complete toolkit for polyline manipulation in AMap applications with proper resource management and cleanup."
  },
  "composables\\useRealtime.ts": {
    "hash": "b00f05f12f5118a47977a21806c0bbb6",
    "last_updated": 1753904321.933191,
    "summary": "This file implements a Vue composable for managing real-time communication with Supabase, specifically designed for a ride-tracking application. The composable provides reactive state management for connection status and channels, along with methods for various real-time operations.\n\n## Key Methods and Functions:\n\n1. **subscribeToRideUpdates(rideId, onUpdate)** - Subscribes to live updates for a specific ride, monitoring both route points and ride status changes in the database\n2. **subscribeToUserRides(onRideUpdate)** - Tracks all rides for the current user to provide notifications about ride updates\n3. **broadcastLocation(rideId, locationData)** - Sends live location data during a ride to other subscribers via broadcast messages\n4. **subscribeToEmergencyAlerts(onEmergencyAlert)** - Listens for emergency alerts broadcast to the current user\n5. **sendEmergencyAlert(location, message)** - Creates a persistent emergency alert in the database and broadcasts it in real-time\n6. **unsubscribeAll()** - Cleans up all active subscriptions when the component unmounts\n7. **unsubscribe(channelTopic)** - Removes a specific subscription by channel topic\n\n## Patterns and Architecture:\n\nThe composable follows Vue 3 Composition API patterns, using refs for reactive state management and onUnmounted for cleanup. It leverages Supabase real-time features including:\n- PostgreSQL change notifications for database updates\n- Broadcast channels for peer-to-peer messaging\n- Channel-based subscription management\n\nThe implementation includes automatic cleanup of subscriptions, connection status tracking, and error handling. Dependencies include other composables (useSupabase, useAuth) for Supabase client access and authentication state. The composable returns readonly refs to prevent direct mutation of internal state while exposing all necessary methods for real-time functionality."
  },
  "composables\\useRideRecording.ts": {
    "hash": "a8b5db456f41fb2f5e65a1c8d96d641f",
    "last_updated": 1753904327.8075154,
    "summary": "This file implements a comprehensive Vue composable for ride recording functionality with persistence, GPS tracking, and data management. It provides a complete system for recording, storing, and managing bicycle/motorbike rides.\n\n## Core Architecture\n- Uses Vue's reactive system with a central `rideRecordingStore` for state management\n- Implements persistence through `LocalRideStorage` class for local storage and file downloads\n- Includes `MockRideAPI` class to simulate backend API interactions\n- Provides automatic state recovery across page refreshes using temporary localStorage\n\n## Key Data Structures\n- `LocationPoint`: GPS coordinates with metadata (accuracy, speed, altitude)\n- `RideMetadata`: Ride information including statistics, timing, and status\n- `PauseEvent`: Records pause/resume events during rides\n- `RideRecord`: Complete ride data combining metadata and location points\n\n## Main Methods\n\n### Ride Lifecycle Management\n- `startRide()`: Initializes new ride recording with metadata\n- `addLocationPoint()`: Adds GPS points with outlier filtering/validation\n- `pauseRide()`/`resumeRide()`: Controls ride pause states\n- `stopRide()`: Completes ride recording and triggers data saving\n\n### Data Persistence\n- `saveRideData()`: Saves rides to both local storage and mock backend\n- `getRideHistory()`: Retrieves ride records from local/remote sources\n- `recoverRecordingState()`: Restores interrupted recording sessions\n- Automatic JSON file downloads with ride data\n\n### Utility Functions\n- `calculateDistance()`: Haversine formula for GPS distance calculation\n- `isValidLocationPoint()`: Filters GPS outliers and invalid data\n- `updateRideStatistics()`: Real-time calculation of ride metrics\n- `formatDuration()`: Time formatting helper\n\n## Key Features\n- **Outlier Detection**: Filters unrealistic GPS points based on speed/distance thresholds\n- **Dual Storage**: Saves to both localStorage and simulated backend API\n- **Session Persistence**: Maintains recording state across browser refreshes\n- **Automatic Recovery**: Restores interrupted rides on app initialization\n- **Comprehensive Statistics**: Real-time distance, speed, and duration tracking\n- **Error Handling**: Robust error management with mock API failure simulation\n- **Debug Tools**: Built-in state inspection and global debug access\n\n## Reactive State Management\nAll ride metrics are exposed as Vue computed properties for reactive UI updates, including recording status, duration, distance, current/max speed, and save status.\n\n## Design Patterns\n- Factory pattern for composable creation\n- Class-based services for storage and API simulation\n- Reactive store pattern with computed getters\n- Automatic cleanup and state persistence\n- Comprehensive error handling and logging"
  },
  "composables\\useStorage.ts": {
    "hash": "1eba314e55cd450deba72df0f6e69561",
    "last_updated": 1753904338.6649756,
    "summary": "This file implements a Vue composable function `useStorage` that provides file storage operations using Supabase storage. The composable manages avatar uploads, ride photo uploads, file downloads, file deletions, and GPX route exports.\n\n## Key Methods:\n\n1. **uploadAvatar** - Uploads user avatar images to the 'avatars' bucket with unique filenames combining user ID and timestamp\n2. **uploadRidePhoto** - Uploads ride-related photos to the 'ride-photos' bucket with organized folder structure\n3. **downloadFile** - Downloads files from specified storage buckets and creates object URLs\n4. **deleteFile** - Removes files from specified storage buckets\n5. **exportRouteAsGPX** - Exports ride route data as GPX XML files to the 'route-exports' bucket\n6. **generateGPX** - Helper function that converts route point data into GPX XML format\n\n## Patterns and Features:\n\n- Uses Vue's `ref` for reactive state management (`uploading` status, `downloadUrl`)\n- Implements comprehensive error handling with try/catch blocks\n- Provides loading state management with `uploading` ref\n- Uses unique filename generation with timestamps to prevent conflicts\n- Implements proper resource cleanup in finally blocks\n- Returns readonly refs for reactive properties\n- Follows consistent return object structure with data, error, and additional metadata\n- Uses Supabase storage client for all storage operations\n- Includes cache control settings for uploaded files\n\nThe composable is designed to handle various file storage needs within a cycling/riding tracking application, with specific support for user avatars, ride photos, and GPS route exports."
  },
  "composables\\useSupabase.ts": {
    "hash": "7af9804f8cc84afe0f967b94b55d3eaa",
    "last_updated": 1753904344.7778826,
    "summary": "This file provides Vue 3 composables for interacting with Supabase/MemFire Cloud services in a Nuxt 3 application. It exports four main composables: `useSupabase`, `useAuth`, `useRides`, and `useRoutePoints`.\n\n## Key Components:\n\n### 1. `useSupabase()`\n- Creates and configures a Supabase client instance\n- Supports both MemFire Cloud and legacy Supabase configurations\n- Uses runtime config with fallbacks for backward compatibility\n- Includes development debugging logs\n- Throws error if URL/key are missing\n\n### 2. `useAuth()`\n- Comprehensive authentication management with global state using `useState`\n- **Phone Authentication**: `signUpWithPhone`, `signInWithPhone`, `sendSmsOtp`, `verifyPhoneOtp`\n- **Social Auth**: `signInWithWechat` (WeChat QR login)\n- **Email Auth**: `signUp`, `signIn`, `signOut`\n- **Password Management**: `resetPassword`\n- **User Management**: `getCurrentUser`, `initializeAuth`\n- Auto-initializes auth state on client side\n- Listens for auth state changes\n- Uses readonly refs for reactive state\n\n### 3. `useRides()`\n- Ride management functionality for a cycling/motorbike tracking app\n- `createRide`: Creates new rides with user association\n- `updateRide`: Updates ride information\n- `finishRide`: Completes rides with end data\n- `getUserRides`: Fetches user's ride history with pagination\n- `getRideById`: Retrieves specific ride details\n- `deleteRide`: Removes rides\n\n### 4. `useRoutePoints()`\n- GPS route tracking functionality\n- `addRoutePoint`: Adds single GPS points to rides\n- `getRoutePoints`: Retrieves all points for a ride\n- `bulkAddRoutePoints`: Efficiently adds multiple points\n\n## Patterns and Features:\n- **Reactive State Management**: Uses Nuxt's `useState` for global auth state\n- **Error Handling**: Comprehensive try/catch with error state management\n- **Type Safety**: Strong typing with Database and User types\n- **Auto-initialization**: Auth state initializes automatically on client\n- **Environment Configuration**: Flexible config supporting multiple providers\n- **Development Debugging**: Conditional logging in development mode\n- **Readonly Reactive Returns**: Exposes state as readonly computed refs\n\nThe file serves as the data access layer for a ride-tracking application with robust authentication and real-time GPS tracking capabilities."
  },
  "layouts\\map-layout.vue": {
    "hash": "921027f47d6f048aaa86399b2892ea70",
    "last_updated": 1753904432.6033695,
    "summary": "This is a Vue 3 single-file component that implements a map-based layout for a mobile application. The layout features a persistent global map container, mobile navigation, and location services.\n\n## Structure and Components\n\n**Template Structure:**\n- Global map container using AMap (AutoNavi Maps) that covers the entire viewport\n- Fixed-position current location button (only visible on '/track' route)\n- Location error notification system with dismiss functionality\n- Main content area overlaid on the map using slots\n- Mobile navigation bar with 5 tabs (Home, Track, Rides, Chat, Profile)\n\n**Key Methods and Functions:**\n\n1. **Map Initialization** (`onMounted`):\n   - Loads AMap JavaScript SDK\n   - Initializes map with dark theme and specific features\n   - Loads required plugins (Geolocation, Geocoder, Polyline, Marker, etc.)\n   - Sets up global map instance\n\n2. **Location Services:**\n   - `locateUser()`: Centers map on current user location with UI feedback\n   - `getUserLocation()`: Retrieves current GPS coordinates\n   - `centerOnCurrentLocation()`: Animates map to center on user position\n   - `startLocationTracking()`: Begins continuous GPS tracking\n   - `startOrientationTracking()`: Starts device compass tracking\n\n3. **State Management:**\n   - Uses composable providers (`useGlobalMapProvider`, `useMapSettingsProvider`, `useAmap`)\n   - Manages loading states, location errors, and UI feedback\n\n**Patterns and Features:**\n\n- **Client-Side Only Rendering**: Uses `<ClientOnly>` wrapper for map component\n- **Responsive Design**: Mobile-first approach with fixed navigation\n- **Error Handling**: Comprehensive location error management with user-friendly messages\n- **UI/UX Enhancements**: Loading states, pulse animations, and visual feedback\n- **Composable Architecture**: Leverages Vue 3 composables for state management\n- **Route-Based Visibility**: Conditional rendering based on current route\n- **CSS Animations**: Pulse effect for location button during GPS acquisition\n\n**Dependencies:**\n- AMap (AutoNavi Maps) JavaScript API\n- Heroicons for UI icons\n- Nuxt 3 framework features (useHead, ClientOnly, NuxtLink)\n\nThe component serves as a foundational layout for map-centric mobile applications, providing core mapping functionality, location services, and navigation structure."
  },
  "middleware\\auth.ts": {
    "hash": "0a2f3ba4aef497693769f54a14859c9a",
    "last_updated": 1753904441.416438,
    "summary": "This file implements a Nuxt.js route middleware for authentication protection. The middleware uses `defineNuxtRouteMiddleware` to create an async function that runs before route navigation. Key patterns and functionality include: 1) Development mode bypass - skips all auth checks when `import.meta.dev` is true, 2) Auth state management - utilizes a composable `useAuth()` that provides user data, loading state, and initialization function, 3) Authentication initialization - ensures the auth system is properly initialized before proceeding, 4) Loading state handling - implements a polling mechanism with timeout (10 attempts with 100ms delays) to wait for auth initialization, 5) Unauthorized access handling - redirects to `/login` with the original route stored as a query parameter when no user is authenticated, 6) Logging - comprehensive console logging for debugging with emoji prefixes (🔧 development, 🛡️ auth checks, ⏳ waiting, 🚫 denied access, ✅ success). The middleware serves as a gatekeeper for protected routes, ensuring only authenticated users can access them while providing a smooth redirect flow for unauthenticated users."
  },
  "middleware\\default-layout.global.ts": {
    "hash": "d08ce3cbb0271bea60a94d3597f524fe",
    "last_updated": 1753904445.7163954,
    "summary": "This file defines a global Nuxt.js route middleware that automatically sets a default layout for pages. The middleware uses the `defineNuxtRouteMiddleware` function to create a route guard that executes before each route navigation. Its primary purpose is to set the layout to 'map-layout' for any page that doesn't already have a layout explicitly defined. The middleware checks if `to.meta.layout` is undefined, and if so, assigns 'map-layout' to it. This follows the pattern of conditional layout assignment based on route metadata, ensuring consistent layout application across the application while respecting explicitly defined page layouts. The middleware is designed to be global, meaning it will run for all routes in the Nuxt.js application."
  },
  "middleware\\guest.ts": {
    "hash": "346551d8b4eb63b73fc13c0391556eb7",
    "last_updated": 1753904448.2151735,
    "summary": "This file implements a Nuxt.js route middleware named 'guest' that restricts access to certain pages (typically login/signup pages) to unauthenticated users only. The middleware uses the `defineNuxtRouteMiddleware` function to create an async route guard.\n\nKey functionality includes:\n\n**Development Mode Handling**: In development environment, the middleware logs a message and allows unrestricted access for testing purposes.\n\n**Authentication State Management**: Uses the `useAuth()` composable to access user authentication state, including user data, loading status, and initialization methods.\n\n**Auth Initialization**: Ensures the authentication system is properly initialized by calling `initializeAuth()` when no user is present and loading is complete.\n\n**Loading State Polling**: Implements a polling mechanism (up to 10 attempts with 100ms delays) to wait for authentication initialization to complete before proceeding.\n\n**Access Control**: Redirects authenticated users away from guest-only pages (like login) to the home page ('/'), while allowing unauthenticated users to access these pages.\n\n**Logging**: Comprehensive console logging throughout the middleware execution for debugging purposes, showing user state, loading status, and middleware decisions.\n\nThe middleware follows the pattern of returning early for redirects (using `navigateTo('/')`) and implicitly allowing access when no return is made. This is a common pattern in Nuxt.js middleware for controlling route access based on authentication state."
  },
  "pages\\chat.vue": {
    "hash": "63cce2861a80a9b4cafc8eb4ee4b09bd",
    "last_updated": 1753904453.5172846,
    "summary": "This is a Vue 3 single-file component implementing a group chat interface for a rider tracking application. The component uses the Composition API with `<script setup>` syntax and includes authentication middleware.\n\n## Purpose\nThe page displays a list of group chat conversations related to riding activities, allowing users to search, refresh, and join conversations.\n\n## Key Features\n- **Header Section**: Contains app branding, activity count, search toggle, and refresh functionality\n- **Search Functionality**: Expandable search bar with clear functionality\n- **Activity Listing**: Displays conversations in card format with activity details\n- **Loading States**: Shows spinner during data loading\n- **Empty State**: Prompts user to join activities when no conversations exist\n\n## Methods and Functions\n- `loadActivities()`: Simulates API call to load conversation data (800ms delay)\n- `refreshActivities()`: Simulates data refresh with spinning animation (1000ms delay)\n- `clearSearch()`: Resets search query and hides search bar\n- `getActivityIcon(type)`: Returns appropriate icon based on activity type\n- `enterChat(activity)`: Handles clicking on a conversation card (currently shows alert)\n- `joinActivity()`: Handles joining new activities (currently shows alert)\n\n## Reactive Data\n- `loading`: Controls loading state display\n- `showSearch`: Toggles search bar visibility\n- `searchQuery`: Stores user search input\n- `activities`: Main data array of conversation objects\n- `refreshing`: Controls refresh button animation\n- `mockActivities`: Sample data for demonstration\n\n## Computed Properties\n- `filteredActivities`: Filters activity list based on search query\n\n## UI Components\n- Custom `AppButton` for join activity action\n- `Icon` component for heroicons integration\n- Responsive card-based layout with hover effects\n- Animated transitions for UI interactions\n\n## Styling Patterns\n- Tailwind CSS utility classes for styling\n- Scoped CSS for component-specific styling\n- CSS transitions for smooth UI interactions\n- Responsive design with flexbox and grid layouts\n\n## Lifecycle\n- `onMounted()`: Triggers initial activity loading\n\nThe component follows modern Vue 3 patterns with Composition API, reactive data management, and computed properties for efficient rendering."
  },
  "pages\\debug-auth.vue": {
    "hash": "fb0619224262f5373446910b1d983fd6",
    "last_updated": 1753904465.506864,
    "summary": "This is a Vue 3 single-file component (SFC) that serves as a debugging interface for authentication functionality in a Nuxt 3 application. The page provides real-time visibility into authentication state, environment configuration, and connection testing capabilities.\n\n## Purpose\nThe primary purpose is to help developers debug authentication issues by displaying current auth state, environment variables, and providing test actions to verify connectivity.\n\n## Key Components and Structure\n\n### Template Structure\n- **Environment Configuration Section**: Displays status of MemFire/Supabase URL and API key configuration with visual indicators (green/red dots)\n- **Authentication State Section**: Shows real-time auth status including initialization state, loading status, user information, and errors\n- **Test Actions Section**: Provides buttons to test database connection and reinitialize authentication\n- **Navigation Section**: Links to login and home pages\n\n### Reactive Data and Computed Properties\n- `envStatus`: Computed property that checks runtime configuration for MemFire/Supabase URL and API key presence\n- `authState`: Computed property that reflects current authentication state including user status and errors\n- `testLoading`: Reactive ref tracking test operation status\n- `testResult`: Reactive ref storing results of test operations\n\n### Methods and Functions\n1. **testSupabaseConnection()**: Async function that tests the database connection by attempting to get the current auth session\n2. **reinitializeAuth()**: Async function that reinitializes the authentication system\n\n### Patterns and Features\n- Uses Vue 3 Composition API with `<script setup>` syntax\n- Leverages Nuxt 3 composables (`useAuth`, `useSupabase`, `useRuntimeConfig`)\n- Implements real-time status monitoring with computed properties\n- Uses Tailwind CSS for styling with a clean, card-based layout\n- Provides visual feedback through color-coded status indicators\n- Includes error handling with try/catch blocks and user-friendly error messages\n- Uses reactive refs for loading states and test results\n- Implements disabled states for buttons during operations\n\n### Dependencies\n- Vue 3 Composition API (computed, ref)\n- Custom composables: useAuth, useSupabase\n- Nuxt 3 runtime configuration\n- Tailwind CSS for styling\n\nThe component is designed to be a developer tool for troubleshooting authentication issues rather than a user-facing feature."
  },
  "pages\\dev-utils.vue": {
    "hash": "c739402ec5f1e54e893b19686dc00eac",
    "last_updated": 1753904479.5812883,
    "summary": "This is a Vue 3 single-file component (SFC) for a development utilities dashboard page. The file implements a comprehensive developer tools interface with multiple functional sections.\n\n## Overall Purpose\nThe page serves as a development and testing dashboard that is only accessible in development mode. It provides quick navigation, environment information display, testing actions, and console logging capabilities for developers working on the application.\n\n## Key Components and Structure\n- **Header Section**: Displays page title '开发工具' (Development Tools) with a development mode indicator\n- **Environment Protection**: Shows a warning message when accessed outside development mode\n- **Quick Navigation Grid**: Provides direct links to key pages (Home, Login, Auth Debug, Track)\n- **Environment Information Panel**: Displays runtime configuration status including MemFire/Supabase credentials and authentication state\n- **Test Actions Section**: Offers interactive testing capabilities (notifications, local storage clearing, page reload)\n- **Console Logs Display**: Shows timestamped development logs in a terminal-like interface\n\n## Methods and Functions\n- `testNotification()`: Displays a temporary test message and logs the action\n- `clearLocalStorage()`: Clears both localStorage and sessionStorage, with confirmation message\n- `reloadPage()`: Triggers a full page reload\n- `addLog(message)`: Adds timestamped log entries to the console display, maintaining only the last 20 entries\n- `onMounted()`: Initializes the console with startup information\n\n## Reactive State Management\n- Uses Vue 3 Composition API with `ref` and `computed`\n- Integrates with `useAuth()` composable for authentication state\n- Environment variables accessed via `import.meta.dev` and `import.meta.client`\n- Runtime configuration accessed via `useRuntimeConfig()`\n\n## Design Patterns\n- **Conditional Rendering**: Content only displays in development mode (`v-if=\"isDev\"`)\n- **Computed Properties**: Environment checks for MemFire configuration\n- **Component Composition**: Uses NuxtLink for navigation, Icon components for visual elements\n- **Scoped Styling**: Custom button styles using Tailwind CSS utility classes\n\n## Technical Features\n- Nuxt 3 specific functionality: `definePageMeta()`, `useHead()`, `useRuntimeConfig()`\n- Responsive grid layouts using Tailwind CSS\n- Real-time console logging with automatic cleanup\n- Environment-aware component behavior\n- Authentication state monitoring\n\nThe component follows modern Vue 3 and Nuxt 3 conventions with script setup syntax, providing a developer-friendly interface for application debugging and testing."
  },
  "pages\\index.vue": {
    "hash": "af033a8232c107d110de6bf4a9f2967f",
    "last_updated": 1753904490.7684946,
    "summary": "This is a Vue 3 single-file component (SFC) for the homepage of a Rider Tracker application built with Nuxt 3. The file follows the standard Vue SFC structure with template, script setup, and scoped styles.\n\n## Overall Purpose\nThe component serves as the main landing page for the Rider Tracker application, providing user authentication-based navigation and displaying global map location status.\n\n## Template Structure\n- **Main Container**: Semi-transparent overlay with blur effect containing all content\n- **Header Section**: Displays application title and welcome message\n- **Conditional Navigation**: \n  - For authenticated users: 'Start Tracking' and 'View My Rides' links\n  - For non-authenticated users: 'Sign In to Start Tracking' link with account creation information\n- **Development Tools**: Conditional section (only visible in dev mode) with links to development utilities and authentication debugging\n- **Map Status Display**: Shows global map activity status with real-time location information\n- **Development Mode Indicator**: Additional info box when in development mode\n\n## Script Setup Composition\n- **Composables**: Uses `useGlobalMap()` for location tracking and `useAuth()` for authentication state\n- **Reactive State**: \n  - `currentLocation`: Tracks user's GPS coordinates\n  - `locationError`: Handles location service errors\n  - `user`: Authentication state from Supabase\n  - `isDev`: Development mode detection\n- **Computed Properties**: \n  - `locationState`: Dynamically computes location status message, color coding, and text based on location data or errors\n- **Methods**: \n  - `formatCoordinates()`: Formats latitude/longitude to 6 decimal places\n- **Watchers**: Monitors location changes with console logging for debugging\n\n## Styling Patterns\n- **Scoped CSS**: Uses Tailwind CSS classes extensively with custom button styles\n- **Responsive Design**: Mobile-first approach with max-width constraints\n- **Visual Feedback**: Color-coded status indicators (green=success, red=error, yellow=waiting)\n- **Conditional Visibility**: Development tools only shown in development mode\n\n## Key Patterns and Features\n- **Conditional Rendering**: Template sections change based on authentication state and development mode\n- **Reactive Data Flow**: Location updates automatically trigger UI changes through computed properties\n- **Development Experience**: Built-in debugging tools and mode detection\n- **User Experience**: Clear call-to-action buttons and status feedback\n- **Internationalization**: Mixed English and Chinese text (primarily Chinese for development tools)\n\nThe component effectively combines user authentication flow with real-time location tracking status, providing a comprehensive dashboard for users to access the application's core features."
  },
  "pages\\login.vue": {
    "hash": "2190e10e78f26be24c028dcd7e5c7e03",
    "last_updated": 1753904505.0204902,
    "summary": "This is a comprehensive login page component built with Vue 3 and Nuxt.js for a cycling tracking application. The component provides multiple authentication methods including phone number login/registration (with OTP or password) and email login/registration.\n\n## Key Features and Methods:\n\n### Authentication Methods:\n- **Phone Authentication**: Supports both OTP-based and password-based login/registration\n- **Email Authentication**: Supports traditional email/password login and registration\n- **Password Reset**: Modal-based password reset functionality\n\n### Core Functions:\n- `sendOtp()`: Sends SMS verification code for phone login\n- `verifyOtp()`: Verifies phone OTP for authentication\n- `sendPasswordOtp()`: Sends registration OTP for phone password registration\n- `registerWithPassword()`: Completes phone registration with password and OTP\n- `loginWithPassword()`: Authenticates user with phone and password\n- `loginWithEmail()`: Email/password authentication\n- `registerWithEmail()`: Email registration with password\n- `handlePasswordReset()`: Processes password reset requests\n\n### UI/UX Features:\n- Responsive design with mobile optimization\n- Tab-based navigation between phone/email login methods\n- Form validation with real-time error feedback\n- Loading states and success messages\n- Cooldown timers for OTP resend functionality\n- Gradient background and glass-morphism design\n- Safe area padding for mobile devices\n\n### State Management:\n- Reactive form data using Vue's `reactive()`\n- Computed properties for form validation (`isPhoneValid`, `isEmailValid`)\n- Multiple UI states for different authentication flows\n- Error handling with contextual help messages\n\n### Technical Patterns:\n- Uses Vue 3 Composition API with `script setup` syntax\n- Integrates with custom `useAuth` composable for authentication logic\n- Implements middleware protection for guest access only\n- Responsive design with Tailwind CSS styling\n- Environment configuration validation\n- Proper error handling and user feedback mechanisms\n\nThe component is designed with a focus on mobile-first experience, Chinese localization, and comprehensive authentication flows supporting both traditional and modern authentication methods."
  },
  "pages\\polyline-simple-copy.vue": {
    "hash": "7ee9ad3c01c80c40e9b3bb9f5eabba79",
    "last_updated": 1753904514.064733,
    "summary": "This Vue 3 component (using Composition API with `<script setup>`) implements an interactive map application for creating, editing, and managing polylines using the AMap (高德地图) JavaScript API. The interface features a responsive layout with a header, map container, control panel, information panel, error display, and instructions.\n\n## Key Methods and Functions:\n\n### Reactive State Management:\n- Uses Vue's `ref` and `computed` for managing component state including `mapReady`, `isDrawing`, `isEditing`, `status`, `error`, and `polylines`\n- Computed properties for dynamic UI updates: `statusClass` (color-coded status), `totalLength` (aggregated polyline distances), and `currentMode` (drawing/editing state)\n\n### Map Initialization and Setup:\n- `initMap()`: Main initialization function that loads AMap script, creates map instance, loads plugins, and sets up tools\n- `loadAmapScript()`: Dynamically loads AMap JavaScript SDK with API key from runtime config\n- `loadPlugins()`: Loads required AMap plugins (MouseTool, PolylineEditor) with timeout handling\n- `getUserLocation()`: Attempts to get user's geolocation with comprehensive error handling and timeouts\n- `setupEventHandlers()`: Configures event listeners for drawing completion and editor events\n\n### Utility Functions:\n- `formatDistance()`: Converts meters to human-readable format (m/km)\n- `calculatePolylineLength()`: Computes total length of a polyline using geographic distance calculation\n- `calculateDistance()`: Implements Haversine formula for calculating distance between two GPS coordinates\n- `setError()` and `clearError()`: Centralized error management with console logging\n\n### User Interaction Methods:\n- `createSamplePolylines()`: Generates three predefined sample polylines near the map center with different colors and patterns\n- `startDrawing()`: Activates polyline drawing mode using AMap's MouseTool\n- `toggleEdit()`: Switches between edit/normal mode for the most recent polyline using PolylineEditor\n- `clearAll()`: Removes all polylines from the map and resets component state\n\n### Lifecycle Management:\n- `onMounted()`: Initializes the map only on client-side (SSR compatible)\n- `onUnmounted()`: Cleans up AMap tools to prevent memory leaks\n\n## Design Patterns and Features:\n\n### Component Architecture:\n- Single-file component with scoped styles\n- Uses Vue 3 Composition API with `script setup` syntax\n- Implements proper error boundaries and user feedback\n- Responsive design with Tailwind CSS classes\n\n### Map Integration:\n- Asynchronous loading of external AMap SDK\n- Plugin-based architecture for map features\n- Comprehensive event handling for user interactions\n- Proper cleanup of map resources\n\n### User Experience:\n- Real-time status updates and visual feedback\n- Disabled states for buttons based on context\n- Color-coded status indicators\n- Detailed instructions for users\n- Error display with dismiss functionality\n\n### Data Management:\n- Maintains local array of polyline references for tracking\n- Calculates and displays aggregate statistics\n- Handles geographic calculations for distance measurement\n- Implements proper state transitions between modes\n\nThe component serves as a complete demonstration of polyline manipulation capabilities with a focus on user-friendly interaction patterns and robust error handling."
  },
  "pages\\polyline-simple.vue": {
    "hash": "bd5cad033b1d406c034b436ca4226718",
    "last_updated": 1753904524.9242158,
    "summary": "This Vue 3 component (polyline-simple.vue) implements an interactive map application using the AMap (高德地图) JavaScript API for creating, editing, and managing polylines. The component features a responsive layout with a header, map container, control panel, information panel, error display, and instructions.\n\n## Key Methods and Functions:\n\n### Lifecycle and Initialization:\n- `initMap()`: Main initialization function that loads AMap script, creates map instance, loads plugins, and sets up tools\n- `loadAmapScript()`: Dynamically loads the AMap JavaScript SDK\n- `loadPlugins()`: Loads required AMap plugins (MouseTool, PolylineEditor)\n- `getUserLocation()`: Attempts to get and center on user's geolocation\n- `setupEventHandlers()`: Configures event listeners for drawing and editing tools\n\n### User Interaction Methods:\n- `createSamplePolylines()`: Generates three sample polylines (square, diagonal line, curved path) at the map center\n- `startDrawing()`: Activates polyline drawing mode using MouseTool\n- `toggleEdit()`: Switches between edit mode for the last created polyline\n- `clearAll()`: Removes all polylines from the map\n\n### Utility Functions:\n- `calculatePolylineLength()`: Computes the total distance of a polyline using geographic calculations\n- `calculateDistance()`: Implements haversine formula for distance calculation between coordinates\n- `formatDistance()`: Formats distance values in meters or kilometers\n- `setError()` and `clearError()`: Manage error state and display\n\n### Reactive State Management:\n- Uses Vue 3 Composition API with refs for mapReady, isDrawing, isEditing, status, error, and polylines\n- Computed properties for statusClass, totalLength, and currentMode\n\n### Design Patterns:\n- Asynchronous initialization with proper error handling\n- Promise-based script and plugin loading with timeouts\n- Event-driven architecture for map interactions\n- Reactive state management with computed properties\n- Cleanup in onUnmounted lifecycle hook\n\nThe component provides a complete user interface for polyline manipulation with real-time feedback, status indicators, and comprehensive error handling. It demonstrates integration of external mapping libraries with Vue 3's reactivity system."
  },
  "pages\\profile.vue": {
    "hash": "8e82926bccf8995338b19b0c525a6e7b",
    "last_updated": 1753904532.8910816,
    "summary": "This is a Vue 3 single-file component for a user profile page in a Rider Tracker application. The component uses the Composition API with `<script setup>` syntax and includes authentication middleware.\n\n## Purpose\nThe profile page displays user information, statistics, and provides access to various account and app settings. It serves as a central hub for user management and app configuration.\n\n## Structure\n- **Template**: Mobile-optimized layout with header, scrollable content area containing profile info, stats, and menu items\n- **Script**: Uses Vue 3 Composition API with reactive state management\n- **Styling**: Scoped CSS with flexbox layout and mobile-friendly scrolling\n\n## Key Methods and Functions\n- **Navigation/Action Handlers**: `editProfile()`, `editAvatar()`, `managePreferences()`, `managePrivacy()`, `exportData()`, `showHelp()`, `showAbout()`, `signIn()`, `signOut()`\n- **Data Management**: `loadProfile()` - loads mock user data and statistics\n- **Authentication**: `signOut()` integrates with auth composable and redirects to login\n- **Formatting Utilities**: `formatDate()` and `formatDistance()` from external utils\n\n## Reactive State\n- `showSettings`: Controls settings panel visibility\n- `isSignedIn`: Authentication status\n- `profile`: User profile data (displayName, email, avatar, etc.)\n- `stats`: Ride statistics (total rides, distance, duration)\n- `appVersion`: Computed property from app configuration\n\n## UI Components and Patterns\n- Mobile-first responsive design with safe area handling\n- Card-based layout with consistent spacing and typography\n- Icon-based navigation using Heroicons\n- Conditional rendering for auth states (sign in/out buttons)\n- Grid layout for statistics display\n- Hover states and transitions for interactive elements\n- Header with title and settings button\n\n## Dependencies\n- Vue 3 Composition API (ref, computed, onMounted)\n- External utilities for date/distance formatting\n- Authentication composable (`useAuth()`)\n- Icon component for Heroicons\n- Routing utilities (`navigateTo`)\n\n## Security and Middleware\n- Implements auth middleware via `definePageMeta()`\n- Protected route requiring authentication\n\nThe component follows modern Vue 3 patterns with a clean separation of concerns and mobile-optimized UI design."
  },
  "pages\\reset-password.vue": {
    "hash": "05c9d906d7c6c8a91d73a3b2fa8b2d4b",
    "last_updated": 1753904540.4808376,
    "summary": "This Vue.js component implements a reset password page for the Rider Tracker application. The page features a clean, modern UI with a card-based layout that includes a header with a key icon, form inputs for new password and confirmation, and appropriate feedback messaging.\n\n## Key Methods and Functions:\n- `handleResetPassword()`: Main async function that validates password matching and length, then uses Supabase auth to update the user's password\n- `onMounted()`: Lifecycle hook that runs when component mounts (currently empty but intended for session validation)\n- Form validation logic that checks password match and minimum length (6 characters)\n\n## Data Management:\n- Reactive refs for form state: `password`, `confirmPassword`, `loading`, `error`, and `success`\n- Uses Supabase client via `useSupabase()` composable for authentication operations\n\n## UI/UX Patterns:\n- Responsive design with mobile-first approach using Tailwind CSS\n- Conditional rendering for error/success messages and form vs success state\n- Loading states with disabled inputs during submission\n- Accessible form labels and input fields\n- Visual feedback through color-coded alert messages (red for errors, green for success)\n- Custom CSS for mobile optimization including touch targets and viewport height handling\n\n## Security Features:\n- Password confirmation matching validation\n- Minimum password length requirement\n- Form disabling during submission to prevent double submissions\n- Automatic error handling with user-friendly messages\n\n## Navigation:\n- Links back to login page\n- Success state with button to navigate to login\n\nThe component is designed to work within the Nuxt.js framework ecosystem, utilizing composables for Supabase integration and following Vue 3 Composition API patterns with script setup syntax."
  },
  "pages\\rides.vue": {
    "hash": "45e0534e10856c72388459bf173f4b95",
    "last_updated": 1753904547.4851186,
    "summary": "This Vue.js component (pages/rides.vue) implements a ride tracking dashboard that displays a user's ride history with filtering and statistics capabilities. The component uses the Composition API with script setup syntax and includes authentication middleware.\n\n## Key Features:\n- **Header with Filtering**: Semi-transparent header with filter toggle showing vehicle type and status dropdowns\n- **Statistics Summary**: Displays total rides, distance, and duration with formatted values\n- **Ride List**: Shows rides in cards with details including title, vehicle type, status, distance, duration, average speed, and creation date\n- **State Management**: Handles loading, empty, and data states with appropriate UI components\n- **Pagination**: Load more functionality for additional rides\n\n## Main Methods and Functions:\n- `loadRides()`: Simulates API call to fetch initial ride data\n- `loadMore()`: Loads additional mock rides when user requests more data\n- `viewRideDetails(ride)`: Handles click events on ride cards (currently shows alert)\n- `getStatusBadgeClass(status)`: Returns CSS classes for status badges based on ride status\n- `getAverageSpeed(ride)`: Calculates and formats average speed for each ride\n- `getVehicleIcon(type)`: Returns appropriate icon for vehicle type (imported utility)\n\n## Computed Properties:\n- `filteredRides`: Filters rides based on selected vehicle type and status, sorted by date\n- `totalRides`: Counts total number of rides\n- `totalDistance`: Sums up all ride distances\n- `totalDuration`: Sums up all ride durations\n\n## Utility Functions (imported):\n- `formatDuration()`: Formats time durations\n- `formatDistance()`: Formats distance values\n- `formatDateTime()`: Formats date/time displays\n- `formatRideStatus()`: Formats ride status text\n- `formatSpeed()`: Formats speed values\n\n## UI Components Used:\n- Custom LoadingSpinner for loading states\n- Custom AppButton for actions\n- Icon component for various icons using Heroicons\n- Responsive grid layouts with Tailwind CSS\n\n## Data Flow:\n- Uses mock data for demonstration purposes\n- Implements reactive filtering through computed properties\n- Handles asynchronous data loading with loading states\n- Uses global map composable (though not directly utilized in this component)\n\n## Design Patterns:\n- Reactive data management with Vue refs and computed properties\n- Component-based architecture with scoped styling\n- Mobile-responsive design with touch-friendly interactions\n- Conditional rendering for different UI states (loading, empty, data)\n- Event-driven interactions (click handlers, filter toggles)"
  },
  "pages\\track.vue": {
    "hash": "328e5ad46913d66bb26a153f79d30912",
    "last_updated": 1753904555.3292587,
    "summary": "# Track Ride Page Analysis\n\n## Overall Purpose\nThis Vue component implements a comprehensive ride tracking application that allows users to record cycling or motorbike rides with real-time location tracking, visual path display on a map, and detailed ride statistics. The interface provides controls for starting, pausing, and stopping rides while maintaining persistent state across page refreshes.\n\n## Key Features and Functionality\n\n### UI Components\n- **Header Section**: Displays page title with settings icon\n- **Quick Actions Panel**: Vehicle selection, location/orientation tracking toggles, map theme and feature controls\n- **Recovered Recording Indicator**: Shows when ride data is restored after page refresh\n- **Ride Status Display**: Visual indicator and text status of current ride\n- **Statistics Panel**: Shows distance, speed, and location points in real-time\n- **Control Buttons**: Start/Pause/Resume/Stop ride functionality\n\n### Core Methods and Functions\n\n#### Ride Control Methods\n- `startRide()`: Initializes ride recording with metadata, starts polyline tracking and timer\n- `pauseRide()`: Pauses recording and changes polyline style to dashed\n- `resumeRide()`: Resumes recording and restores polyline style\n- `stopRide()`: Stops recording, saves data, and displays completion statistics\n\n#### Timer Management\n- `startTimer()`: Manages elapsed time calculation with support for resume functionality\n- `stopTimer()`: Clears the timing interval\n\n#### Map Settings\n- `onThemeChange()`: Updates map theme when user selection changes\n- `toggleMapFeature()`: Enables/disables map features like traffic or points of interest\n- `isFeatureEnabled()`: Checks if specific map feature is active\n\n#### State Management\n- `initializeComponent()`: Restores UI settings and recording state on component mount\n- `setRecoveredRideInfo()`: Displays recovery notification with auto-hide functionality\n- `dismissRecoveredRideInfo()`: Manually clears recovery notification\n\n#### Device Tracking\n- `toggleOrientationTracking()`: Controls device compass/heading tracking\n- `toggleLocationTracking()`: Toggles GPS location services\n\n### Reactive Data Properties\n- `selectedVehicle`: User's chosen vehicle type (bicycle/motorbike)\n- `showSettings`: Controls settings panel visibility\n- `currentSpeed/Heading`: Real-time device location data\n- `recoveredRideInfo`: Stores information about restored recording sessions\n- `selectedTheme/availableThemes`: Map appearance configuration\n\n### Composables Integration\n- `useGlobalMap()`: Manages location and orientation tracking\n- `useMapSettings()`: Handles map theme and feature preferences\n- `useRideRecording()`: Core ride data management and persistence\n- `useMapPolylines()`: Visual path rendering on map\n- `useRouteTracking()`: Additional route tracking functionality\n\n### Design Patterns\n- **Composable Architecture**: Leverages Vue 3 composables for separation of concerns\n- **Reactive State Management**: Uses Vue's reactivity system for real-time UI updates\n- **Persistent State**: Implements temporary storage for UI settings and ride recovery\n- **Watchers**: Monitors location changes and state updates for automatic UI refresh\n- **Computed Properties**: Dynamically calculates ride status, distance, and duration\n\n### Error Handling and User Feedback\n- Comprehensive try/catch blocks around async operations\n- Visual status indicators with color coding (red=recording, yellow=paused, green=stopped)\n- Alert notifications for operation success/failure\n- Location state messaging with color-coded status\n\n### Cleanup and Lifecycle Management\n- Proper cleanup of timers, intervals, and tracking services on component unmount\n- Automatic state recovery across page refreshes\n- Resource management for map polylines and tracking services\n\nThe component demonstrates a well-structured approach to real-time location tracking with attention to user experience, data persistence, and proper resource management."
  },
  "plugins\\auth.client.ts": {
    "hash": "d9d646e77c637d45ada0ef41ab548ab9",
    "last_updated": 1753904570.9883122,
    "summary": "This file is a Nuxt 3 plugin that handles client-side authentication initialization. The plugin uses the `defineNuxtPlugin` function to create an asynchronous plugin that runs during the application startup process. \n\nKey components:\n- `defineNuxtPlugin(async () => {...})`: Defines an async Nuxt plugin that will be executed when the application starts\n- `useAuth()`: Composable function that provides authentication functionality, from which `initializeAuth` is destructured\n- `initializeAuth()`: An asynchronous function that initializes the authentication system, likely setting up user state, tokens, or authentication listeners\n\nThe pattern used here is a startup initialization pattern where authentication state is hydrated or set up as soon as the client-side application begins. This ensures that any authenticated user state is available throughout the application lifecycle. The plugin is specifically named with the `.client.ts` extension, indicating it only runs on the client side, not during server-side rendering."
  },
  "plugins\\global-map.ts": {
    "hash": "cb8ea7bd13fb3c0c19a8cfc69689fb64",
    "last_updated": 1753904574.6139574,
    "summary": "This file is a Nuxt 3 plugin that initializes and provides a global map state management system. The plugin imports the `useGlobalMapProvider` composable function from '~/composables/useGlobalMap' and uses it to create a global map state instance. The plugin follows Nuxt's plugin pattern by using `defineNuxtPlugin` and returns a provider object that makes the global map state available throughout the application via the `$globalMap` injection. The plugin logs an initialization message to the console when loaded. The main purpose is to centralize map state management and make it accessible globally across the Nuxt application. Key patterns include: Nuxt 3 plugin architecture, composable pattern for state management, and dependency injection via the provide/inject mechanism."
  },
  "plugins\\map-layout.ts": {
    "hash": "432c777b35078565bec58ef86717801d",
    "last_updated": 1753904577.2709417,
    "summary": "This file is a Nuxt 3 plugin that sets up a map layout as the default layout for the application. The plugin uses the `defineNuxtPlugin` function to create a plugin that hooks into the Nuxt application lifecycle. Specifically, it listens for the 'app:mounted' event which triggers when the application is fully mounted in the browser. At this point, it logs a message to the console indicating that the map layout plugin has been initialized. The primary purpose appears to be establishing a map-based layout as the default UI structure, likely for an application that centers around map functionality. The plugin follows the standard Nuxt 3 plugin pattern using the hook system for initialization timing."
  },
  "public\\robots.txt": {
    "hash": "243b03ecba82dde9612cd5163145a86d",
    "last_updated": 1753904579.4257252,
    "summary": "This is a robots.txt file located in the public directory, which is used to provide instructions to web crawlers and search engine bots about which parts of the website they are allowed to access. The file contains two directives: 'User-Agent: *' which applies the rules to all web crawlers and bots, and 'Disallow:' which is empty, meaning no restrictions are placed on crawling any parts of the website. This is a standard pattern for allowing full access to all content, essentially giving permission to search engines and other bots to index the entire site. There are no methods or functions in this file as it's a simple text-based configuration file following the Robots Exclusion Protocol standard."
  },
  "scripts\\setup-linux.sh": {
    "hash": "eaa9151af0db2db36269ad87da4d56b5",
    "last_updated": 1753904581.737715,
    "summary": "This is a Bash shell script designed to automate the setup process for the Rider Tracker App on Linux systems. The script follows a sequential execution pattern with conditional checks and user guidance.\n\n**Main Functions and Methods:**\n1. **Dependency Validation**: Uses `command -v` to check if pnpm package manager is installed\n2. **Automated Installation**: Installs pnpm globally using npm if not found, with fallback instructions for Node.js installation\n3. **Environment Configuration**: Checks for existing .env file and creates one from .env.example template, or generates a basic configuration file with placeholder values\n4. **Package Installation**: Executes `pnpm install` to install project dependencies with error handling\n5. **User Guidance**: Provides clear status messages, emojis for visual feedback, and step-by-step next steps\n\n**Key Patterns:**\n- Conditional logic with if/else statements for error handling\n- File existence checks using `[ -f ]` syntax\n- Heredoc (`<< EOF`) for multi-line file creation\n- Exit codes (exit 1) for error termination\n- Command output redirection (`&> /dev/null`) for silent command execution\n\n**Overall Purpose:** The script streamlines the development environment setup by ensuring all prerequisites (pnpm, environment variables) are configured correctly and provides clear instructions for users to complete the setup process, specifically targeting Linux distributions with different package managers (Ubuntu/Debian, CentOS/RHEL, Fedora)."
  },
  "scripts\\setup-macos.sh": {
    "hash": "76b92a2b3f671f08f2ee1ab59392f21c",
    "last_updated": 1753904585.5181227,
    "summary": "This is a Bash shell script designed to automate the setup process for the Rider Tracker App on macOS systems. The script follows a sequential execution pattern with conditional checks and error handling.\n\n**Main Methods and Functions:**\n\n1. **Dependency Validation**: Checks for pnpm package manager installation using `command -v pnpm`, with automatic installation via npm if missing\n2. **Environment Configuration**: Verifies .env file existence and creates it from .env.example template or generates a basic configuration file with placeholder values for MemFire Cloud and Amap API keys\n3. **Package Installation**: Executes `pnpm install` to install project dependencies with success/failure validation\n4. **User Guidance**: Provides clear console output with emojis indicating status (success, warning, error) and step-by-step instructions\n\n**Key Patterns:**\n- Conditional execution using if/else statements\n- Error handling with exit codes (exit 1 on failure)\n- File existence checking with `[ -f ]` syntax\n- Heredoc (`<< EOF`) for multi-line file creation\n- Command output redirection (`&> /dev/null`) for silent execution\n- Progressive disclosure of information with clear section headers\n\n**Overall Purpose:** The script streamlines the Rider Tracker App setup process by automating dependency installation, environment configuration, and providing clear next steps for developers, reducing manual setup errors and improving onboarding experience."
  },
  "scripts\\setup-windows.js": {
    "hash": "27be5c3c7455a5b9998c448c669eba70",
    "last_updated": 1753904590.962277,
    "summary": "This is a Node.js setup script for Windows environments that automates the initialization of a Rider Tracker application. The script follows a sequential execution pattern with clear logging and error handling.\n\n**Main Functions and Methods:**\n- Uses Node.js built-in modules: `fs` for file operations, `path` for path resolution, and `child_process.execSync` for executing shell commands\n- `execSync()` is used extensively for running CLI commands with synchronous execution\n- `fs.existsSync()` to check file existence\n- `fs.copyFileSync()` to copy .env.example to .env\n- `fs.writeFileSync()` to create a basic .env file when example is missing\n\n**Key Patterns:**\n- Try-catch blocks for error handling around critical operations\n- Conditional logic flow based on file existence and command availability\n- Progress logging with emoji indicators for user feedback\n- Synchronous execution pattern for predictable setup flow\n\n**Setup Process:**\n1. Verifies pnpm installation and installs it globally if missing\n2. Checks for .env file and creates it from .env.example or generates a basic template\n3. Installs project dependencies using pnpm\n4. Provides clear next steps for the user\n\n**Purpose:** Automates the Windows development environment setup for a Nuxt.js application that uses MemFire Cloud (Supabase alternative) and Amap (Gaode Maps) services, ensuring developers have the required dependencies and configuration files."
  },
  "server\\tsconfig.json": {
    "hash": "32a978380246c0479e2c9fb9dd0cf7ab",
    "last_updated": 1753904595.9691665,
    "summary": "This is a TypeScript configuration file (tsconfig.json) for the server-side code. The file uses the 'extends' property to inherit configuration from '../.nuxt/tsconfig.server.json', which is a generated Nuxt.js TypeScript configuration file. This approach allows the server-side TypeScript compilation to use the same base settings as the Nuxt.js framework while potentially allowing for project-specific overrides. There are no custom methods, functions, or patterns defined in this file - it solely serves as a configuration extension point. The purpose is to maintain consistency with the Nuxt.js TypeScript setup while providing flexibility for server-specific TypeScript compilation settings."
  },
  "types\\database.ts": {
    "hash": "7f7335f328bb2238a81245fa1e1f99b8",
    "last_updated": 1753904597.939278,
    "summary": ""
  },
  "utils\\constants.ts": {
    "hash": "64f79eb76fde8e92603b36152d9894f0",
    "last_updated": 1753904611.1371272,
    "summary": "This TypeScript file defines application-wide constants organized into logical categories for a cycling and motorbike tracking application called 'Rider Tracker'. The file does not contain any methods or functions, but rather serves as a centralized configuration store using constant objects and type definitions.\n\n## Key Constant Categories:\n\n**App Configuration**: Basic app metadata including name, version, description and author.\n\n**Map Configuration**: Map display and tracking parameters including zoom levels (default: 15, max: 20, min: 3), tracking accuracy (50m), minimum tracking distance (5m), tracking interval (3000ms), and maximum tracking points (10,000).\n\n**Location Tracking**: Geolocation settings with high accuracy enabled, maximum age (30s), timeout (15s), watch interval (3s), and minimum distance (10m).\n\n**Storage Management**: Local storage keys prefixed with 'rider_tracker_' for different data types (location, preferences, ride settings, offline rides) and configuration including 10MB max size and 'rt_' key prefix.\n\n**Domain Constants**: Immutable vehicle types (bicycle, motorbike) and ride statuses (recording, paused, completed, cancelled) defined with TypeScript's `as const` for type safety.\n\n**API Configuration**: REST endpoint paths for rides, route points, profiles, and authentication.\n\n**UI/UX Settings**: Responsive breakpoints (mobile: 768px, tablet: 1024px, desktop: 1280px), modal dimensions, toast duration (3s), and loading delays (200ms).\n\n**Validation Rules**: Input validation for email (regex pattern), password (min 8 chars), ride titles (3-100 chars), and descriptions (max 500 chars).\n\n**User Preferences**: Default settings for theme, language, units, notifications, privacy, and tracking behaviors with sensible defaults for better UX.\n\n**Messaging**: Comprehensive error and success messages organized by category (network, location, auth, ride) for consistent user feedback.\n\n**Performance & Features**: Monitoring configuration (10% sample rate), feature flags for offline mode, social features, analytics, and push notifications.\n\n**Location Correction**: GPS coordinate adjustments with pre-calculated latitude and longitude deltas to correct for API biases.\n\n## Patterns and Design:\n\n- **Centralized Configuration**: All constants are exported individually for granular imports\n- **Type Safety**: Uses TypeScript's `as const` and type inference for domain constants\n- **Organizational Clarity**: Constants grouped by functional area with clear comments\n- **Scalability**: Feature flags enable/disable functionality without code changes\n- **User Experience Focus**: Default preferences and UI settings prioritize usability\n\nThe file serves as the single source of truth for application configuration, enabling consistent behavior across components and facilitating easier maintenance and updates."
  },
  "utils\\formatters.ts": {
    "hash": "8d6b09937bca6ebd7e4fdfb6cc93e712",
    "last_updated": 1753904620.083512,
    "summary": "This file contains a comprehensive collection of formatting utilities organized into logical categories. The main categories include: Time formatting (formatDuration, formatDate, formatTime, formatDateTime) which handle various time display formats; Distance formatting (formatDistance, formatSpeed, formatAltitude) for metric measurements; Coordinate formatting (formatCoordinate, formatLatitude, formatLongitude) with directional indicators; Vehicle type formatting (formatVehicleType, getVehicleIcon) for display names and icons; Status formatting (formatRideStatus, getStatusColor) with color coding; File size formatting (formatFileSize) using standard units; Number formatting (formatNumber) with locale support; Validation helpers (isValidCoordinate, isValidEmail) for data validation; and URL helpers (createMapUrl, createShareUrl) for generating links. The file follows a consistent pattern of pure functions that take specific parameters and return formatted strings or boolean values. All functions are exported individually, making them easily importable. The code demonstrates good practices with proper error handling, edge case management, and clear naming conventions."
  }
}