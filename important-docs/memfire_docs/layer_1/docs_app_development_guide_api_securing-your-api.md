# 开始使用 | MemFire Cloud在线文档

**URL:** https://docs.memfiredb.com/docs/app/development_guide/api/securing-your-api/
**Layer/Depth:** 1

[MemFireDB备份 6](/)

menu

[官网](https://memfiredb.com/)
[论坛](https://community.memfiredb.com/)
[登录](https://cloud.memfiredb.com/auth/login)

Enable dark mode

Enable light mode

本页

开始使用

# 开始使用

## 开始使用 [*link*](#%e5%bc%80%e5%a7%8b%e4%bd%bf%e7%94%a8)

所有的API都是由数据库表自动创建的。在你向数据库添加了表或函数后，你可以使用所提供的API。

### 创建API路由 [*link*](#%e5%88%9b%e5%bb%baapi%e8%b7%af%e7%94%b1)

当你创建Postgres表、视图或函数时，会自动创建API路由。

让我们通过创建一个叫做`todos`的表来存储任务，来创建我们的第一个API路由。
这将创建一个相应的路由`todos`，它可以接受`GET`、`POST`、`PATCH`和`DELETE`请求。

1. 进入仪表板中的表编辑器页面。
2. 点击**新表**，创建一个名为`todos`的表。
3. 单击**保存**。
4. 点击**新列**，创建一个名为`task`的列，类型为`text`。
5. 单击**保存**。

[

](../../../videos/api/api-create-table-sm.mp4)

```
-- Create a table called "todos" with a column to store tasks.

create table todos (
  id bigint generated by default as identity primary key,
  task text check (char_length(task) > 3)
);
```

### API URL和密钥 [*link*](#api-url%e5%92%8c%e5%af%86%e9%92%a5)

每个Supabase项目都有一个独特的API URL。您的 API 在 API 网关后面是安全的，每次请求都需要一个 API 密钥。

1. 转到仪表板中的设置页面。
2. 单击侧栏中的 **API**。
3. 在这个页面上找到你的API`URL`、`anon`和`service_role`键。

[

](../../../videos/api/api-url-and-key.mp4)

REST API和GraphQL API都可以通过这个URL访问:

* REST: `https://<project_ref>.supabase.co/rest/v1`
* GraphQL: `https://<project_ref>.supabase.co/graphql/v1`

这两重路由都需要通过`apikey`标头来传递`anon`密钥。

#### API密钥 [*link*](#api%e5%af%86%e9%92%a5)

您将获得两个密钥：

* 一个`anon` 密钥, 在浏览器环境下使用是安全的。
* 一个`service_role`密钥，只能在服务器上使用。这个密钥可以绕过行级安全。千万不要在浏览器中使用这个密钥。

### 访问仪表板中的文档 [*link*](#%e8%ae%bf%e9%97%ae%e4%bb%aa%e8%a1%a8%e6%9d%bf%e4%b8%ad%e7%9a%84%e6%96%87%e6%a1%a3)

#### REST API [*link*](#rest-api)

MemFire Cloud在[Dashboard](https://cloud.memfiredb.com/)中生成文档，当你对数据库进行修改时，该文档会更新。
让我们查看在数据库中创建的`countries`表的文档。

1. 转到仪表板中的API页面。
2. 在侧边栏的表和视图下找到 `countries`表。
3. 使用标签在JavaScript和cURL文档之间切换。

[

](../../../videos/api/api-docs.mp4)

#### GraphQL [*link*](#graphql)

我们提供的GraphQL端点（`https://<project_ref>.supabase.co/graphql/v1`）与任何能够传递`apikey`头的GraphiQL实现兼容。

一些建议的应用:

* [paw.cloud](https://paw.cloud)
* [insomnia.rest](https://insomnia.rest)
* [postman.com/graphql](https://www.postman.com/graphql/)
* 自我托管的GraphiQL: GraphiQL可以通过一个简单的HTML文件提供服务。更多细节请参见[讨论](https://github.com/supabase/supabase/discussions/6144).

## 使用API [*link*](#%e4%bd%bf%e7%94%a8api)

### REST API [*link*](#rest-api-1)

你可以直接通过HTTP请求与你的API交互，或者可以使用我们提供的客户端库。

让我们看看如何向在第一步创建的`todos`表提出请求。
使用提供的API URL（`SUPABASE_URL`）和Key（`SUPABASE_ANON_KEY`）。

```
// Initialize the JS client
import { createClient } from '@supabase/supabase-js'
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

// Make a request
const { data: todos, error } = await supabase.from('todos').select('*')
```

```
# Append /rest/v1/ to your URL, and then use the table name as the route
curl '<SUPABASE_URL>/rest/v1/todos' \
-H "apikey: <SUPABASE_ANON_KEY>" \
-H "Authorization: Bearer <SUPABASE_ANON_KEY>"
```

JS 参考: [select()](/docs/app/sdkdocs/javascript/database/select/),
[insert()](/docs/app/sdkdocs/javascript/database/insert/),
[update()](/docs/app/sdkdocs/javascript/database/update/),
[upsert()](/docs/app/sdkdocs/javascript/database/upsert/),
[delete()](/docs/app/sdkdocs/javascript/database/delete/),
[rpc()](/docs/app/sdkdocs/javascript/database/rpc/) (调用Postgres函数).

### GraphQL API [*link*](#graphql-api)

你可以在任何GraphQL客户端调用Supabase GraphQL API。对于我们的GraphQL例子，我们将使用[urql](https://formidable.com/open-source/urql/docs/)。

```
import { createClient, useQuery } from 'urql'

// Prepare API key and Authorization header
const headers = {
  apikey: <SUPABASE_ANON_KEY>,
  authorization: `Bearer ${<SUPABASE_ANON_KEY}`>
}

// Create GraphQL client
// See: https://formidable.com/open-source/urql/docs/basics/react-preact/#setting-up-the-client
const client = createClient({
  url: '<SUPABASE_URL>/graphql/v1',
  fetchOptions: function createFetchOptions() {
    return { headers }
  },
})

// Prepare our GraphQL query
const TodosQuery = `
  query {
    todosCollection {
      edges {
        node {
          id
          title
        }
      }
    }
  }
`

// Query for the data (React)
const [result, reexecuteQuery] = useQuery({
  query: TodosQuery,
})

// Read the result
const { data, fetching, error } = result
```

```
# Append /graphql/v1/ to your URL, and then use the table name as the route
curl --request POST '<SUPABASE_URL>/graphql/v1' \
-H 'apikey: <SUPABASE_ANON_KEY>' \
-H 'Authorization: Bearer <SUPABASE_ANON_KEY>' \
-d '{ "query":"{ todos(first: 3) { edges { node { id } } } }" }'
```

### 实时API [*link*](#%e5%ae%9e%e6%97%b6api)

默认情况下，Realtime在你的数据库中是禁用的。让我们为`todos`表打开Realtime。

1. 进入仪表板中的**数据库**页面。
2. 点击侧边栏中的**复制**。
3. 通过切换**插入**、**更新**和**删除**来控制哪些数据库事件被发送。
4. 通过选择**Source**和切换每个表来控制哪些表被发送变化。

[

](../../docs/videos/api/api-realtime.mp4)

```
alter publication supabase_realtime add table todos;
```

从客户端，我们可以监听插入`todos’表的任何新数据：

```
// Initialize the JS client
import { createClient } from '@supabase/supabase-js'
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

// Create a function to handle inserts
const handleInserts = (payload) => {
  console.log('Change received!', payload)
}

// Listen to inserts
const { data: todos, error } = await supabase.from('todos').on('INSERT', handleInserts).subscribe()
```

使用[subscribe()](/docs/app/sdkdocs/javascript/realtime/subscribe/)来监听数据库变化。
实时API通过PostgreSQL的复制功能工作。Postgres将数据库变化发送到一个叫做`supabase_realtime`的[发布](/docs/app/development_guide/database/replication#publications)，通过管理这个发布，你可以控制哪些数据被广播。

## API安全 [*link*](#api%e5%ae%89%e5%85%a8)

### 保护你的路由安全 [*link*](#%e4%bf%9d%e6%8a%a4%e4%bd%a0%e7%9a%84%e8%b7%af%e7%94%b1%e5%ae%89%e5%85%a8)

你的API被设计成与Postgres行级安全（RLS）一起工作。如果你使用Supabase [Auth](/docs/app/development_guide/auth/auth/)，你可以根据登录的用户来限制数据。
为了控制对数据的访问，你可以使用[Policy](/docs/app/development_guide/auth/auth/#policies)。
当你在Postgres中创建一个表时，默认情况下，行级安全是被禁用的。要启用RLS：

1. 进入仪表板中的认证页面。
2. 单击侧边栏中的*政策*。
3. 选择**启用RLS**来启用行级安全。

```
alter table todos enable row level security;
```

### `service_role`密钥 [*link*](#service_role%e5%af%86%e9%92%a5)

不要在浏览器或用户可以看到的任何地方暴露 `service_role` 密钥。这个密钥是为了绕过行级安全而设计的 - 所以它只应该在私人服务器上使用。

`service_role`密钥的一个常见用例是在后端运行数据分析工作。为了支持用户ID的连接，授予服务角色对`auth.users`表的读取权限通常是有用的。

```
grant select on table auth.users to service_role;
```

我们已经[与GitHub合作](https://github.blog/changelog/2022-03-28-supabase-is-now-a-github-secret-scanning-partner/)，扫描推送到公共存储库的Supabase `service_role`密钥。
如果他们检测到任何具有service\_role权限的密钥被推送到GitHub，他们将把API密钥转发给我们，这样我们就可以自动撤销检测到的秘密并通知你，保护你的数据免受恶意行为的影响。

### 对意外删除和更新的保障措施 [*link*](#%e5%af%b9%e6%84%8f%e5%a4%96%e5%88%a0%e9%99%a4%e5%92%8c%e6%9b%b4%e6%96%b0%e7%9a%84%e4%bf%9d%e9%9a%9c%e6%8e%aa%e6%96%bd)

对于所有项目，默认情况下，Postgres扩展[safeupdate](https://github.com/eradman/pg-safeupdate)对所有来自API的查询都是启用的。
这可以确保任何 `delete()`或 `update()`在没有附带过滤器的情况下会失败。
为了确认通过你的项目的API进行的查询是否启用了safeupdate，可以运行以下查询：

```
select usename,useconfig from pg_shadow where usename = 'authenticator' ;
```

`useconfig`的预期值应该是：

```
['session_preload_libraries=supautils, safeupdate']
```

---

[*navigate\_before* 使用cURL工具访问数据](/docs/app/development_guide/api/curl/)

[创建 API 路由 *navigate\_next*](/docs/app/development_guide/api/creating-routes/)